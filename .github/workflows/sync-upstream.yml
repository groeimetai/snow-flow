name: Sync Upstream (OpenCode)

on:
  workflow_dispatch:
    inputs:
      force:
        description: "Force sync even if an open sync issue already exists"
        type: boolean
        default: false
  schedule:
    - cron: "0 7 * * 1" # Every Monday at 07:00 UTC

permissions:
  contents: write
  issues: write

jobs:
  sync-upstream:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Add upstream remote and fetch
        run: |
          git remote add upstream https://github.com/anomalyco/opencode.git || true
          git fetch upstream dev --tags

      - name: Detect new upstream commits
        id: detect
        run: |
          # Use tracking tag to find last checked upstream commit.
          # Falls back to listing the last 4 weeks of upstream commits on first run.
          if git rev-parse "upstream-sync/last-checked" >/dev/null 2>&1; then
            LAST_CHECKED=$(git rev-parse "upstream-sync/last-checked")
            echo "last_checked=$LAST_CHECKED" >> "$GITHUB_OUTPUT"
            NEW_COMMITS=$(git rev-list --count "$LAST_CHECKED"..upstream/dev)
            echo "new_commits=$NEW_COMMITS" >> "$GITHUB_OUTPUT"
            echo "Found $NEW_COMMITS new upstream commits since tag upstream-sync/last-checked ($LAST_CHECKED)"
          else
            echo "No tracking tag found — first run. Listing last 4 weeks of upstream commits."
            SINCE_DATE=$(date -d '4 weeks ago' +%Y-%m-%d 2>/dev/null || date -v-4w +%Y-%m-%d)
            LAST_CHECKED=$(git rev-list --after="$SINCE_DATE" upstream/dev | tail -1)
            if [ -z "$LAST_CHECKED" ]; then
              LAST_CHECKED=$(git rev-list upstream/dev | tail -1)
            fi
            echo "last_checked=$LAST_CHECKED" >> "$GITHUB_OUTPUT"
            NEW_COMMITS=$(git rev-list --count "$LAST_CHECKED"..upstream/dev)
            echo "new_commits=$NEW_COMMITS" >> "$GITHUB_OUTPUT"
            echo "first_run=true" >> "$GITHUB_OUTPUT"
            echo "Found $NEW_COMMITS upstream commits since $SINCE_DATE"
          fi

          # Store upstream HEAD for tagging later
          UPSTREAM_HEAD=$(git rev-parse upstream/dev)
          echo "upstream_head=$UPSTREAM_HEAD" >> "$GITHUB_OUTPUT"

      - name: Skip if no new commits
        if: steps.detect.outputs.new_commits == '0'
        run: |
          echo "No new upstream commits found. Nothing to do."

      - name: Check for existing sync issue
        if: steps.detect.outputs.new_commits != '0'
        id: existing
        uses: actions/github-script@v7
        with:
          script: |
            const force = context.payload.inputs?.force === 'true';
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'upstream-sync',
              per_page: 10
            });

            const syncIssue = issues[0];

            if (syncIssue && !force) {
              core.setOutput('exists', 'true');
              core.setOutput('issue_number', syncIssue.number.toString());
              core.info(`Existing sync issue found: #${syncIssue.number}`);
            } else {
              core.setOutput('exists', 'false');
              core.setOutput('issue_number', '');
            }

      - name: Ensure labels exist
        if: steps.detect.outputs.new_commits != '0' && steps.existing.outputs.exists == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;

            async function ensureLabel(name, color, description) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name });
              } catch {
                await github.rest.issues.createLabel({ owner, repo, name, color, description });
                core.info(`Created label: ${name}`);
              }
            }

            await ensureLabel('upstream-sync', '0e8a16', 'Upstream sync from anomalyco/opencode');

      - name: Build commit list and create issue
        if: steps.detect.outputs.new_commits != '0' && steps.existing.outputs.exists == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const lastChecked = '${{ steps.detect.outputs.last_checked }}';
            const newCommits = parseInt('${{ steps.detect.outputs.new_commits }}');
            const isFirstRun = '${{ steps.detect.outputs.first_run }}' === 'true';

            const { execSync } = require('child_process');
            const commitLog = execSync(
              `git log --oneline --no-merges ${lastChecked}..upstream/dev | head -50`
            ).toString().trim();

            const diffStats = execSync(
              `git diff --stat ${lastChecked}..upstream/dev | tail -1`
            ).toString().trim();

            // Group commits by conventional commit type
            const lines = commitLog.split('\n').filter(Boolean);
            const grouped = {};
            for (const line of lines) {
              const match = line.match(/^[a-f0-9]+ (feat|fix|docs|chore|refactor|test|perf|ci|build|style)(\(.+?\))?[!]?:/);
              const type = match ? match[1] : 'other';
              if (!grouped[type]) grouped[type] = [];
              grouped[type].push(line);
            }

            let body = `## Upstream Sync from anomalyco/opencode\n\n`;
            if (isFirstRun) {
              body += `> :information_source: **First run** — showing upstream commits from the last 4 weeks.\n\n`;
            }
            body += `**${newCommits} new commit(s)** on upstream \`dev\` branch.\n\n`;
            body += `### Diff Stats\n\`\`\`\n${diffStats}\n\`\`\`\n\n`;

            body += `### New Upstream Commits\n`;
            if (newCommits > 50) {
              body += `_Showing first 50 of ${newCommits} commits:_\n`;
            }

            // Show grouped commits for easier scanning
            const typeLabels = { feat: 'Features', fix: 'Fixes', refactor: 'Refactors', docs: 'Docs', chore: 'Chores', test: 'Tests', perf: 'Performance', ci: 'CI', build: 'Build', style: 'Style', other: 'Other' };
            for (const [type, commits] of Object.entries(grouped)) {
              body += `\n**${typeLabels[type] || type}** (${commits.length})\n`;
              body += `\`\`\`\n${commits.join('\n')}\n\`\`\`\n`;
            }

            body += `\n### Cherry-Pick Workflow\n`;
            body += `Due to extensive rebranding (opencode → snow-flow/snow-code), direct merging is not possible. Cherry-pick relevant commits individually.\n\n`;
            body += `\`\`\`bash\n`;
            body += `git remote add upstream https://github.com/anomalyco/opencode.git 2>/dev/null || true\n`;
            body += `git fetch upstream dev\n\n`;
            body += `# Review a commit\n`;
            body += `git show <commit-hash>\n\n`;
            body += `# Cherry-pick it\n`;
            body += `git cherry-pick <commit-hash>\n`;
            body += `# If conflicts: resolve, then git cherry-pick --continue\n`;
            body += `\`\`\`\n\n`;
            body += `### After Review\n`;
            body += `Close this issue when done. The tracking tag will be updated automatically on the next workflow run.\n`;

            const { data: issue } = await github.rest.issues.create({
              owner,
              repo,
              title: `chore: upstream sync review ${new Date().toISOString().split('T')[0]}`,
              body,
              labels: ['upstream-sync']
            });

            core.info(`Created issue #${issue.number}`);

      - name: Update existing sync issue with comment
        if: steps.detect.outputs.new_commits != '0' && steps.existing.outputs.exists == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const issueNumber = parseInt('${{ steps.existing.outputs.issue_number }}');
            const lastChecked = '${{ steps.detect.outputs.last_checked }}';
            const newCommits = '${{ steps.detect.outputs.new_commits }}';

            const { execSync } = require('child_process');
            const commitLog = execSync(
              `git log --oneline --no-merges ${lastChecked}..upstream/dev | head -20`
            ).toString().trim();

            const body = `### Upstream Sync Update (${new Date().toISOString().split('T')[0]})\n\n` +
              `There are now **${newCommits} commit(s)** to review on upstream \`dev\`.\n\n` +
              `**Latest upstream commits:**\n\`\`\`\n${commitLog}\n\`\`\`\n\n` +
              `> Use \`workflow_dispatch\` with \`force: true\` to create a fresh sync issue.`;

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: issueNumber,
              body
            });

            core.info(`Added update comment to issue #${issueNumber}`);

      - name: Update tracking tag
        if: steps.detect.outputs.new_commits != '0'
        run: |
          UPSTREAM_HEAD="${{ steps.detect.outputs.upstream_head }}"
          # Update (or create) the tracking tag pointing to latest checked upstream commit
          git tag -f "upstream-sync/last-checked" "$UPSTREAM_HEAD"
          git push origin "upstream-sync/last-checked" --force

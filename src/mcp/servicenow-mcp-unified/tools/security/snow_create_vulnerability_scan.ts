/**
 * ServiceNow Security Tool: Create Vulnerability Scan
 * Creates vulnerability scanning configurations
 * Source: servicenow-security-compliance-mcp.ts
 */

import { SnowToolConfig } from '../types';

export const snow_create_vulnerability_scan: SnowToolConfig = {
  name: 'snow_create_vulnerability_scan',
  description: 'Creates vulnerability scanning configurations. Schedules scans, sets severity thresholds, and enables auto-remediation.',
  inputSchema: {
    type: 'object',
    properties: {
      name: { type: 'string', description: 'Scan name' },
      scope: { type: 'string', description: 'Scan scope (application, platform, integrations)' },
      schedule: { type: 'string', description: 'Scan schedule' },
      severity: { type: 'string', description: 'Minimum severity to report' },
      notifications: { type: 'array', description: 'Notification recipients' },
      remediation: { type: 'boolean', description: 'Auto-remediation enabled' },
      active: { type: 'boolean', description: 'Scan active status' }
    },
    required: ['name', 'scope']
  },
  handler: async (args, client, logger) => {
    logger.info('Creating Vulnerability Scan...');

    // Get available scan types and schedules
    const scanTypes = await getScanTypes(client, logger);
    const schedules = await getAvailableSchedules(client, logger);

    const scanData = {
      name: args.name,
      scope: args.scope,
      schedule: args.schedule || 'weekly',
      severity: args.severity || 'medium',
      notifications: JSON.stringify(args.notifications || []),
      remediation: args.remediation || false,
      active: args.active !== false
    };

    await client.ensureUpdateSet();

    // Try vulnerability management tables
    let response;
    const vulnTables = [
      'sn_vul_scan',              // Vulnerability Response scans
      'sn_vul_vulnerability',     // Vulnerability records
      'scan_check_run',           // Security scan runs
      'u_vulnerability_scan'      // Custom table fallback
    ];

    for (const tableName of vulnTables) {
      try {
        // Adjust field names for vulnerability tables
        const tableSpecificData = tableName.startsWith('sn_vul_') ? {
          name: args.name,
          short_description: args.name,
          scan_type: args.scope || 'application',
          schedule: args.schedule || 'on_demand',
          active: args.active !== false,
          auto_remediate: args.remediation === true,
          notify_on_complete: args.notifications ? args.notifications.join(',') : ''
        } : scanData;

        response = await client.createRecord(tableName, tableSpecificData);
        if (response.success) {
          logger.info(`Vulnerability scan created in table: ${tableName}`);
          break;
        }
      } catch (tableError) {
        logger.warn(`Failed to create in table ${tableName}:`, tableError);
        continue;
      }
    }

    if (!response || !response.success) {
      throw new Error(`Failed to create Vulnerability Scan: ${response?.error || 'No suitable table found'}`);
    }

    return {
      content: [{
        type: 'text',
        text: `âœ… Vulnerability Scan created successfully!\n\nğŸ” **${args.name}**\nğŸ†” sys_id: ${response.data.sys_id}\nğŸ¯ Scope: ${args.scope}\nğŸ“… Schedule: ${args.schedule || 'weekly'}\nğŸš¨ Min Severity: ${args.severity || 'medium'}\nğŸ“§ Notifications: ${args.notifications?.length || 0} recipients\n${args.remediation ? 'ğŸ”§ Auto-remediation: Enabled\n' : ''}\nğŸ”„ Active: ${args.active !== false ? 'Yes' : 'No'}\n\nâœ¨ Created with dynamic scan configuration discovery!`
      }]
    };
  }
};

// Helper functions
async function getScanTypes(client: any, logger: any): Promise<string[]> {
  try {
    const scanTypes = await client.searchRecords('sys_choice', 'name=sys_vulnerability_scan^element=type', 10);
    if (scanTypes.success) {
      return scanTypes.data.result.map((choice: any) => choice.value);
    }
  } catch (error) {
    logger.warn('Could not discover scan types, using defaults');
  }
  return ['application', 'platform', 'integrations', 'network'];
}

async function getAvailableSchedules(client: any, logger: any): Promise<string[]> {
  try {
    const schedules = await client.searchRecords('cmn_schedule', '', 20);
    if (schedules.success) {
      return schedules.data.result.map((schedule: any) => schedule.name);
    }
  } catch (error) {
    logger.warn('Could not discover schedules, using defaults');
  }
  return ['daily', 'weekly', 'monthly'];
}

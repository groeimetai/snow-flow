package dialog

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"time"

	tea "github.com/charmbracelet/bubbletea/v2"
	"github.com/charmbracelet/lipgloss/v2"
	"github.com/sst/opencode/internal/app"
	"github.com/sst/opencode/internal/components/modal"
	"github.com/sst/opencode/internal/components/toast"
	"github.com/sst/opencode/internal/layout"
	"github.com/sst/opencode/internal/styles"
	"github.com/sst/opencode/internal/theme"
	"github.com/sst/opencode/internal/util"
	"github.com/sst/opencode/internal/viewport"
)

type reportDialog struct {
	width    int
	height   int
	modal    *modal.Modal
	app      *app.App
	viewport viewport.Model
}

func (r *reportDialog) Init() tea.Cmd {
	return r.viewport.Init()
}

func (r *reportDialog) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmds []tea.Cmd

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		r.width = msg.Width
		r.height = msg.Height
		maxWidth := min(80, msg.Width-8)
		r.viewport = viewport.New(viewport.WithWidth(maxWidth-4), viewport.WithHeight(msg.Height-6))
	case tea.KeyMsg:
		switch msg.String() {
		case "c", "y":
			// Copy report to clipboard
			return r, tea.Sequence(
				app.SetClipboard(r.getReportMarkdown()),
				toast.NewSuccessToast("Bug report copied to clipboard!"),
			)
		case "g":
			// Create GitHub issue
			return r, r.createGitHubIssue()
		case "esc":
			return r, util.CmdHandler(modal.CloseModalMsg{})
		}
	}

	r.viewport.SetContent(r.renderContent())

	var vpCmd tea.Cmd
	r.viewport, vpCmd = r.viewport.Update(msg)
	cmds = append(cmds, vpCmd)

	return r, tea.Batch(cmds...)
}

// getAuthStatus returns sanitized auth status (no secrets!)
func (r *reportDialog) getAuthStatus() (authType, instance, tokenStatus string) {
	// Check for ServiceNow instance from env
	instance = os.Getenv("SNOW_INSTANCE")
	if instance == "" {
		instance = os.Getenv("SERVICENOW_INSTANCE_URL")
	}
	if instance != "" {
		// Sanitize instance URL - just show the subdomain
		instance = sanitizeInstanceURL(instance)
	} else {
		instance = "Not configured"
	}

	// Check auth type
	authJsonPath := filepath.Join(os.Getenv("HOME"), ".local", "share", "snow-code", "auth.json")
	if _, err := os.Stat(authJsonPath); err == nil {
		// Check if servicenow key exists (don't read actual credentials)
		authType = "Local (auth.json exists)"
		tokenStatus = "Present"
	} else {
		// Check macOS path
		macAuthPath := filepath.Join(os.Getenv("HOME"), "Library", "Application Support", "snow-code", "auth.json")
		if _, err := os.Stat(macAuthPath); err == nil {
			authType = "Local (auth.json exists)"
			tokenStatus = "Present"
		} else {
			authType = "Not configured"
			tokenStatus = "Missing"
		}
	}

	// Check for enterprise auth
	enterprisePath := filepath.Join(os.Getenv("HOME"), ".snow-code", "enterprise.json")
	if _, err := os.Stat(enterprisePath); err == nil {
		authType = "Enterprise"
	}

	return authType, instance, tokenStatus
}

// sanitizeInstanceURL removes sensitive parts from URL
func sanitizeInstanceURL(url string) string {
	// Extract just the instance name, e.g., "dev12345" from "https://dev12345.service-now.com"
	url = strings.TrimPrefix(url, "https://")
	url = strings.TrimPrefix(url, "http://")
	parts := strings.Split(url, ".")
	if len(parts) > 0 {
		return parts[0] + ".service-now.com"
	}
	return url
}

// getConfigStatus returns which config files exist
func (r *reportDialog) getConfigStatus() []string {
	var configs []string
	home := os.Getenv("HOME")

	paths := map[string]string{
		"~/.local/share/snow-code/auth.json":           filepath.Join(home, ".local", "share", "snow-code", "auth.json"),
		"~/Library/Application Support/snow-code/":     filepath.Join(home, "Library", "Application Support", "snow-code"),
		"~/.snow-code/enterprise.json":                 filepath.Join(home, ".snow-code", "enterprise.json"),
		"~/.snow-flow/":                                filepath.Join(home, ".snow-flow"),
		".mcp.json":                                    filepath.Join(r.app.Project.Worktree, ".mcp.json"),
	}

	for name, path := range paths {
		if _, err := os.Stat(path); err == nil {
			configs = append(configs, name)
		}
	}

	return configs
}

// getReportMarkdown returns the bug report in markdown format
func (r *reportDialog) getReportMarkdown() string {
	authType, instance, tokenStatus := r.getAuthStatus()
	configs := r.getConfigStatus()

	var report strings.Builder

	report.WriteString("## Bug Report (Auto-generated by /report)\n\n")
	report.WriteString("> Please review this auto-generated report before submitting!\n\n")

	// System Info
	report.WriteString("### System Info\n\n")
	report.WriteString(fmt.Sprintf("- **OS:** %s (%s)\n", runtime.GOOS, runtime.GOARCH))
	report.WriteString(fmt.Sprintf("- **Go Version:** %s\n", runtime.Version()))
	report.WriteString(fmt.Sprintf("- **Snow-Flow Version:** %s\n", r.app.Version))
	report.WriteString(fmt.Sprintf("- **Generated:** %s\n", time.Now().Format(time.RFC3339)))

	// Auth Status
	report.WriteString("\n### Auth Status\n\n")
	report.WriteString(fmt.Sprintf("- **Auth Type:** %s\n", authType))
	report.WriteString(fmt.Sprintf("- **Instance:** %s\n", instance))
	report.WriteString(fmt.Sprintf("- **Token Status:** %s\n", tokenStatus))

	// Configuration
	report.WriteString("\n### Configuration\n\n")
	if len(configs) > 0 {
		report.WriteString("Config files found:\n")
		for _, cfg := range configs {
			report.WriteString(fmt.Sprintf("- %s\n", cfg))
		}
	} else {
		report.WriteString("No config files found\n")
	}

	// Current Model/Agent
	report.WriteString("\n### Current Setup\n\n")
	if r.app.Provider != nil {
		report.WriteString(fmt.Sprintf("- **Provider:** %s\n", r.app.Provider.Name))
	}
	if r.app.Model != nil {
		report.WriteString(fmt.Sprintf("- **Model:** %s\n", r.app.Model.Name))
	}
	agent := r.app.Agent()
	report.WriteString(fmt.Sprintf("- **Agent:** %s (%s)\n", agent.Name, agent.Mode))

	// Problem Description (placeholder for user)
	report.WriteString("\n### Problem Description\n\n")
	report.WriteString("<!-- Please describe the problem you encountered -->\n\n")

	// Steps to Reproduce
	report.WriteString("\n### Steps to Reproduce\n\n")
	report.WriteString("1. \n2. \n3. \n\n")

	// Expected vs Actual
	report.WriteString("\n### Expected vs Actual Behavior\n\n")
	report.WriteString("**Expected:** \n\n")
	report.WriteString("**Actual:** \n\n")

	return report.String()
}

// createGitHubIssue opens gh CLI to create an issue
func (r *reportDialog) createGitHubIssue() tea.Cmd {
	return func() tea.Msg {
		// Check if gh is installed
		if _, err := exec.LookPath("gh"); err != nil {
			return toast.NewErrorToast("GitHub CLI (gh) not installed. Please install it first.")
		}

		report := r.getReportMarkdown()

		// Create a temp file with the report
		tmpFile, err := os.CreateTemp("", "snow-flow-report-*.md")
		if err != nil {
			return toast.NewErrorToast("Failed to create temp file")
		}
		tmpFilePath := tmpFile.Name()

		if _, err := tmpFile.WriteString(report); err != nil {
			os.Remove(tmpFilePath)
			return toast.NewErrorToast("Failed to write report")
		}
		tmpFile.Close()

		// Open gh issue create in browser with pre-filled body
		// Use Run() (blocking) instead of Start() to ensure file exists during execution
		cmd := exec.Command("gh", "issue", "create",
			"--repo", "groeimetai/snow-flow",
			"--title", "[Bug Report] ",
			"--body-file", tmpFilePath,
			"--web")

		err = cmd.Run()

		// Clean up temp file after gh command completes
		os.Remove(tmpFilePath)

		if err != nil {
			return toast.NewErrorToast("Failed to open GitHub. Use 'c' to copy report instead.")
		}

		return toast.NewSuccessToast("Opening GitHub issue creator in browser...")
	}
}

func (r *reportDialog) renderContent() string {
	t := theme.CurrentTheme()

	labelStyle := styles.NewStyle().
		Foreground(t.TextMuted()).
		Background(t.BackgroundPanel()).
		Width(18)

	valueStyle := styles.NewStyle().
		Foreground(t.Text()).
		Background(t.BackgroundPanel()).
		Bold(true)

	sectionStyle := styles.NewStyle().
		Foreground(t.Primary()).
		Background(t.BackgroundPanel()).
		Bold(true).
		MarginTop(1).
		MarginBottom(1)

	hintStyle := styles.NewStyle().
		Foreground(t.TextMuted()).
		Background(t.BackgroundPanel()).
		Faint(true)

	warningStyle := styles.NewStyle().
		Foreground(t.Warning()).
		Background(t.BackgroundPanel()).
		Bold(true)

	var content string

	// Header
	content += sectionStyle.Render("Bug Report Generator") + "\n\n"
	content += warningStyle.Render("No credentials or secrets will be included!") + "\n"

	// System Info
	content += "\n" + sectionStyle.Render("System Info") + "\n\n"
	content += labelStyle.Render("OS:") + valueStyle.Render(fmt.Sprintf("%s/%s", runtime.GOOS, runtime.GOARCH)) + "\n"
	content += labelStyle.Render("Go Version:") + valueStyle.Render(runtime.Version()) + "\n"
	content += labelStyle.Render("Snow-Flow:") + valueStyle.Render(r.app.Version) + "\n"

	// Auth Status
	authType, instance, tokenStatus := r.getAuthStatus()
	content += "\n" + sectionStyle.Render("Auth Status") + "\n\n"
	content += labelStyle.Render("Auth Type:") + valueStyle.Render(authType) + "\n"
	content += labelStyle.Render("Instance:") + valueStyle.Render(instance) + "\n"
	content += labelStyle.Render("Token Status:") + valueStyle.Render(tokenStatus) + "\n"

	// Config Files
	configs := r.getConfigStatus()
	content += "\n" + sectionStyle.Render("Configuration") + "\n\n"
	if len(configs) > 0 {
		for _, cfg := range configs {
			content += labelStyle.Render("") + valueStyle.Render(cfg) + "\n"
		}
	} else {
		content += labelStyle.Render("") + valueStyle.Render("No config files found") + "\n"
	}

	// Current Model/Agent
	content += "\n" + sectionStyle.Render("Current Setup") + "\n\n"
	if r.app.Provider != nil {
		content += labelStyle.Render("Provider:") + valueStyle.Render(r.app.Provider.Name) + "\n"
	}
	if r.app.Model != nil {
		content += labelStyle.Render("Model:") + valueStyle.Render(r.app.Model.Name) + "\n"
	}
	agent := r.app.Agent()
	content += labelStyle.Render("Agent:") + valueStyle.Render(fmt.Sprintf("%s (%s)", agent.Name, agent.Mode)) + "\n"

	// Actions
	content += "\n" + hintStyle.Render("Press 'c' to copy • 'g' to create GitHub issue • 'esc' to close")

	return content
}

func (r *reportDialog) View() string {
	t := theme.CurrentTheme()
	return lipgloss.NewStyle().
		Background(t.BackgroundPanel()).
		Render(r.viewport.View())
}

func (r *reportDialog) Render(background string) string {
	return r.modal.Render(r.View(), background)
}

func (r *reportDialog) Close() tea.Cmd {
	return nil
}

type ReportDialog interface {
	layout.Modal
}

func NewReportDialog(app *app.App) ReportDialog {
	vp := viewport.New(viewport.WithHeight(28))
	return &reportDialog{
		app:      app,
		modal:    modal.New(modal.WithTitle("Bug Report"), modal.WithMaxWidth(80)),
		viewport: vp,
	}
}
